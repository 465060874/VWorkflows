/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package eu.mihosoft.vrl.workflow;

import edu.uci.ics.jung.algorithms.layout.DAGLayout;
import edu.uci.ics.jung.algorithms.layout.KKLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;
import edu.uci.ics.jung.graph.DirectedGraph;
import edu.uci.ics.jung.graph.DirectedSparseGraph;
import edu.uci.ics.jung.graph.util.Pair;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalGraphMouse;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Paint;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.util.Collection;
import java.util.LinkedList;
import javafx.collections.ObservableList;
import javax.swing.JFrame;
import org.apache.commons.collections15.Transformer;

/** 
 * @author Tobias Mertz
 * Layout generator class using the Jung Graph Drawing Library.
 * Idea:
 * - nodes and edges are separated by their associated edge priority.
 * - highest priority is modeled as Jung-Library Directed Graph.
 * - nodes with in-degree of 0 are set to the left of the available area.
 * - layout of the other nodes is generated using one of Jung's layouting algorithms
 * - nodes push each other away to remove overlaps
 * - nodes and edges of next priority are added to the model
 * - node positions of highest priority are set
 * - node positions of second priority are generated by layouting algorithm
 * - remove overlaps
 * - add nodes of last priority
 * - ...
 * 
 * ToDo:
 * - open up interface for more possibility to interfere with the process
 * - resulting layout inconsistent.
 *      . different results with debugging enabled / disabled
 *      . different results when using multiple algorithms one after another
 * - Priority get / set methods
 * - Priority separation of nodes and edges
 * - forcePush method needs to be altered. Currently not 100% guaranteed to remove all overlaps.
 */
public class LayoutGeneratorSmart implements LayoutGenerator {
    
    private boolean debug;
    private VFlow workflow;
    private String[] priority;
    private VNode[] nodes;
    private DirectedGraph<VNode, Connection> jgraph;
    private Layout<VNode, Connection> layout;
    private int nodecount;
    private int conncount;
    
    private Pair<Integer>[] origin;
    
    /**
     * Default contructor.
     * Debugging is disabled and default layout is CircleLayout.
     */
    public LayoutGeneratorSmart() {
        this.debug = false;
        this.priority = new String[3];
        this.priority[0] = "";
        this.priority[1] = "";
        this.priority[2] = "";
        this.jgraph = new DirectedSparseGraph<>();
        this.layout = new KKLayout<>(this.jgraph);
        this.layout.setSize(new Dimension(1000, 1000));
    }
    
    /**
     * Constructor with workflow parameter.
     * @param pworkflow VFlow: workflow to be setup.
     */
    public LayoutGeneratorSmart(VFlow pworkflow) {
        this.workflow = pworkflow;
        this.debug = false;
        this.priority = new String[3];
        this.priority[0] = "";
        this.priority[1] = "";
        this.priority[2] = "";
        this.jgraph = new DirectedSparseGraph<>();
        this.layout = new KKLayout<>(this.jgraph);
        this.layout.setSize(new Dimension(1000, 1000));
    }
    
    /**
     * Constructor with debug-functionality.
     * @param pdebug Boolean: debugging output enable/disable.
     */
    public LayoutGeneratorSmart(boolean pdebug) {
        this.debug = pdebug;
        this.priority = new String[3];
        this.priority[0] = "";
        this.priority[1] = "";
        this.priority[2] = "";
        this.jgraph = new DirectedSparseGraph<>();
        this.layout = new KKLayout<>(this.jgraph);
        this.layout.setSize(new Dimension(1000, 1000));
        if(this.debug) System.out.println("Creating Layout Generator.");
    }
    
    /**
     * Constructor with debug-functionality and workflow parameter.
     * @param pworkflow VFlow: workflow to be setup.
     * @param pdebug Boolean: debugging output enable/disable.
     */
    public LayoutGeneratorSmart(VFlow pworkflow, boolean pdebug) {
        this.workflow = pworkflow;
        this.debug = pdebug;
        this.priority = new String[3];
        this.priority[0] = "";
        this.priority[1] = "";
        this.priority[2] = "";
        this.jgraph = new DirectedSparseGraph<>();
        this.layout = new KKLayout<>(this.jgraph);
        this.layout.setSize(new Dimension(1000, 1000));
        if(this.debug) System.out.println("Creating Layout Generator.");
    }
    
    /**
     * 
     * @return 
     */
    @Override
    public boolean getDebug() {
        return this.debug;
    }
    
    /**
     * 
     * @return 
     */
    @Override
    public VFlow getWorkflow() {
        return this.workflow;
    }
    
    /**
     * 
     * @return 
     */
    //@Override
    public VNode[] getModelNodes() {
        return this.nodes;
    }
    
    /**
     * 
     * @return 
     */
    public DirectedGraph getModelGraph() {
        return this.jgraph;
    }
    
    /**
     * 
     * @return 
     */
    public String[] getPriority() {
        return this.priority;
    }
    
    /**
     * 
     * @return 
     */
    public Layout<VNode, Connection> getLayout() {
        return this.layout;
    }
    
    /**
     * 
     * @param pdebug 
     */
    @Override
    public void setDebug(boolean pdebug) {
        this.debug = pdebug;
    }
    
    /**
     * 
     * @param pworkflow 
     */
    @Override
    public void setWorkflow(VFlow pworkflow) {
        this.workflow = pworkflow;
    }
    
    /**
     * 
     * @param pnodes 
     */
    //@Override
    public void setModelNodes(VNode[] pnodes) {
        this.nodes = pnodes;
    }
    
    /**
     * 
     * @param pjgraph 
     */
    public void setModelGraph(DirectedGraph pjgraph) {
        this.jgraph = pjgraph;
    }
    
    /**
     * 
     * @param pr0
     * @param pr1
     * @param pr2 
     */
    public void setPriority(String pr0, String pr1, String pr2) {
        this.priority = new String[3];
        this.priority[0] = pr0;
        this.priority[1] = pr1;
        this.priority[2] = pr2;
    }
    
    /**
     * 
     * @param playout 
     */
    public void setLayout(Layout<VNode, Connection> playout) {
        this.layout = playout;
    }
    
    /**
     * 
     */
    private void allNodesSetUp() {
        ObservableList<VNode> nodesTemp = this.workflow.getNodes();
        this.nodecount = nodesTemp.size();
        this.nodes = new VNode[this.nodecount];
        
        int i;
        for(i = 0; i < this.nodecount; i++) {
            this.nodes[i] = nodesTemp.get(i);
            this.jgraph.addVertex(this.nodes[i]);
        }
        
        // Setting up edges
        Connections controlConnections = this.workflow.getConnections("control");
        Connections dataConnections = this.workflow.getConnections("data");
        Connections eventConnections = this.workflow.getConnections("event");
        
        //For seperation of connectiontypes change from here
        ObservableList<Connection> allConnections = controlConnections.getConnections();
        allConnections.addAll(dataConnections.getConnections());
        allConnections.addAll(eventConnections.getConnections());
        this.conncount = allConnections.size();
        
        for(i = 0; i < this.conncount; i++) {
            Connection currConn = allConnections.get(i);
            VNode sender = this.nodes[getNodeID(currConn.getSender().getNode())];
            VNode receiver = this.nodes[getNodeID(currConn.getReceiver().getNode())];
            this.jgraph.addEdge(currConn, sender, receiver);
        }
    }
    
    /**
     * 
     * @param prio
     * @return 
     */
    private ObservableList<VNode> oneNodesSetUp(int prio) {
        Connections connections = this.workflow.getConnections(this.priority[prio]);
        ObservableList connList = connections.getConnections();
        this.conncount += connList.size();
        
        int i;
        for(i = 0; i < this.conncount; i++) {
            Connection currConn = (Connection) connList.remove(0);
            VNode sender = currConn.getSender().getNode();
            VNode receiver = currConn.getReceiver().getNode();
            if(!(this.jgraph.containsVertex(sender))) 
                this.jgraph.addVertex(sender);
            if(!(this.jgraph.containsVertex(receiver)))
                this.jgraph.addVertex(receiver);
            this.jgraph.addEdge(currConn, sender, receiver);
        }
        
        if(prio == 2) {
            ObservableList<VNode> nodesTemp = this.workflow.getNodes();
            this.nodecount = nodesTemp.size();
        
            for(i = 0; i < this.nodecount; i++) {
                VNode currVert = nodesTemp.remove(0);
                if(!(this.jgraph.containsVertex(currVert)))
                    this.jgraph.addVertex(currVert);
            }
        }
        
        ObservableList<VNode> nodesTemp = (ObservableList<VNode>) this.jgraph.getVertices();
        return nodesTemp;
    }
    
    
    /**
     * 
     */
    public void launchOrigin() {
        allNodesSetUp();
        stepOrigin();
        stepLayoutApply();
    }
    
    /**
     * 
     */
    public void launchJungLayout() {
        allNodesSetUp();
        stepLayoutApply();
    }
    
    /**
     * 
     */
    public void launchForcePush() {
        allNodesSetUp();
        this.origin = getOrigin();
        forcePush(this.origin);
    }
    
    /**
     * Generates a Layout for the workflow given.
     */
    @Override
    public void generateLayout() {
        if(this.debug) System.out.println("Generating layout.");
        
        // Setting up nodes
        if(this.priority[0].equals("")) {
            if(this.priority[1].equals("")) {
                if(this.priority[2].equals("")) {
                    // "", "", "" - all priorities equal
                    allNodesSetUp();
                    allSteps();
                }
                else {
                    // "", "", "X" - X has lowest priority. the other two are equal
                    // run 0, 1
                    int i;
                    this.conncount = 0;
                    ObservableList<VNode> nodesTemp0 = oneNodesSetUp(0);
                    ObservableList<VNode> nodesTemp1 = oneNodesSetUp(1);
                    this.nodecount = nodesTemp1.size();
                    this.nodes = new VNode[this.nodecount];
                    for(i = 0; i < nodesTemp1.size(); i++) {
                        this.nodes[i] = nodesTemp1.remove(0);
                    }
                    allSteps();
                    // run 2
                    ObservableList<VNode> nodesTemp2 = oneNodesSetUp(2);
                    this.nodecount = nodesTemp2.size();
                    this.nodes = new VNode[this.nodecount];
                    for(i = 0; i < this.nodecount; i++) {
                        this.nodes[i] = nodesTemp2.remove(0);
                    }
                    allSteps();
                }
            }
            else {
                // "", "X", "Y" - invalid
                if(this.debug) System.out.println("Wrong Priorities!");
                return;
            }
        }
        else {
            // run 0
            int i;
            this.conncount = 0;
            ObservableList<VNode> nodesTemp0 = oneNodesSetUp(0);
            this.nodecount = nodesTemp0.size();
            this.nodes = new VNode[this.nodecount];
            for(i = 0; i < this.nodecount; i++) {
                this.nodes[i] = nodesTemp0.remove(0);
            }
            allSteps();
            if(this.priority[1].equals("")) {
                if(this.priority[2].equals("")) {
                    // "X", "", ""
                    // run 1, 2
                    ObservableList<VNode> nodesTemp1 = oneNodesSetUp(1);
                    ObservableList<VNode> nodesTemp2 = oneNodesSetUp(2);
                    this.nodecount = nodesTemp2.size();
                    this.nodes = new VNode[this.nodecount];
                    for(i = 0; i < this.nodecount; i++) {
                        this.nodes[i] = nodesTemp2.remove(0);
                    }
                }
                else {
                    // "X", "", "Y" - invalid
                    if(this.debug) System.out.println("Wrong Priorities!");
                    return;
                }
            }
            else {
                if(this.priority[2].equals("")) {
                    // "X", "Y", "" - invalid
                    if(this.debug) System.out.println("Wrong Priorities!");
                    return;
                }
                else {
                    // "X", "Y", "Z"
                    // run 1
                    ObservableList<VNode> nodesTemp1 = oneNodesSetUp(1);
                    this.nodecount = nodesTemp1.size();
                    this.nodes = new VNode[this.nodecount];
                    for(i = 0; i < this.nodecount; i++) {
                        this.nodes[i] = nodesTemp1.remove(0);
                    }
                    allSteps();
                    // run 2
                    ObservableList<VNode> nodesTemp2 = oneNodesSetUp(2);
                    this.nodecount = nodesTemp2.size();
                    this.nodes = new VNode[this.nodecount];
                    for(i = 0; i < this.nodecount; i++) {
                        this.nodes[i] = nodesTemp1.remove(0);
                    }
                    allSteps();
                }
            }
        }
        if(this.debug) testvis(this.layout);
    }
    
    /**
     * 
     */
    private void allSteps() {
        stepOrigin();
        stepLayoutApply();
        forcePush(this.origin);
    }
    
    /**
     * 
     */
    private void stepLayoutApply() {
        int i;
        // set layout coordinates
        for(i = 0; i < this.nodecount; i++) {
            Point2D coords;
            coords = this.layout.transform(this.nodes[i]);
            this.nodes[i].setX(coords.getX());
            this.nodes[i].setY(coords.getY());
            if(this.debug) System.out.println(this.nodes[i].getId() + " | X: " + coords.getX() + " Y: " + coords.getY());
        }
    }
    
    /**
     * 
     */
    private void stepOrigin() {
        int i;
        // get origin nodes
        this.origin = getOrigin();
        this.origin = quickSortDesc(this.origin);
        // sort origin nodes by successor-count
        this.origin = triangularOrigin(this.origin);
        
        // place origin nodes on x=0
        double lastpos = 0.;
        for(i = 0; i < this.origin.length; i++) {
            Point2D coords = new Point2D.Double();
            coords.setLocation(0., lastpos);
            lastpos += this.nodes[this.origin[i].getFirst()].getHeight();
            layout.setLocation(this.nodes[this.origin[i].getFirst()], coords);
        }
    }
    
    /**
     * Gets all origin nodes of the graph created at SetUp.
     * origin nodes are all nodes with an in-degree of 0.
     * @return Pair<Integer>[]: Array of Pairs. Each Pair contains the model-ID 
     * of the node and its successor count.
     */
    private Pair<Integer>[] getOrigin() {
        int i;
        LinkedList<Integer> originL = new LinkedList<>();
        for(i = 0; i < this.nodecount; i++) {
            if(this.jgraph.inDegree(this.nodes[i]) == 0) originL.add(i);
        }
        // get successorcount of origin nodes
        int length = originL.size();
        Pair<Integer>[] origina = new Pair[length];
        for(i = 0; i < length; i++) {
            int curr = originL.removeFirst();
            origina[i] = new Pair<>(curr, this.jgraph.getSuccessorCount(this.nodes[curr]));
            if(this.debug) System.out.println(this.nodes[curr].getId() + " | In-Degree: " + this.jgraph.inDegree(this.nodes[curr]) + " Successors: " + this.jgraph.getSuccessorCount(this.nodes[curr]));
        }
        return origina;
    }
    
    /**
     * Sorts an Array of origin nodes in descending order by their successor 
     * count via Quicksort.
     * @param origin Pair<Integer>[]: Array to be sorted.
     * @return Pair<Integer>[]: Sorted Array.
     */
    private Pair<Integer>[] quickSortDesc(Pair<Integer>[] porigin) {
        // cancellation
        if(porigin.length <= 1) {
            return porigin;
        }
        
        // setup
        int l = 1;
        int r = porigin.length - 1;
        Pair<Integer> pivot = porigin[0];
        Pair<Integer> temp;
        
        // sort
        while(l < r) {
            if((porigin[l].getSecond() <= pivot.getSecond()) && (porigin[r].getSecond() > pivot.getSecond())) {
                temp = porigin[r];
                porigin[r] = porigin[l];
                porigin[l] = temp;
            }
            else {
                if(porigin[l].getSecond() > pivot.getSecond()) l++;
                if(porigin[r].getSecond() <= pivot.getSecond()) r--;
            }
        }
        
        // split array into left and right arrays
        Pair<Integer>[] left;
        Pair<Integer>[] right;
        int leftcount = 0;
        int i;
        for(i = 1; i < porigin.length; i++) {
            if(porigin[i].getSecond() > pivot.getSecond()) leftcount++;
        }
        left = new Pair[leftcount];
        right = new Pair[porigin.length - leftcount - 1];
        for(i = 1; i < porigin.length; i++) {
            if(porigin[i].getSecond() > pivot.getSecond()) left[i-1] = porigin[i];
            else right[i-leftcount-1] = porigin[i];
        }
        
        // sort left and right arrays
        left = quickSortDesc(left);
        right = quickSortDesc(right);
        
        // fuse left and right arrays back together
        for(i = 0; i < left.length; i++) {
            porigin[i] = left[i];
        }
        porigin[i] = pivot;
        i++;
        while(i < porigin.length) {
            porigin[i] = right[i - leftcount-1];
            i++;
        }
        return porigin;
    }
    
    /**
     * Sorts a descending Array into a triangular shape of ascending size up to 
     * the maximum value at the center position, followed by descending values.
     * @param origin Pair<Integer>[]: Array of origin nodes sorted in descending 
     *  order by their successor count.
     * @return Pair<Integer>[]: Sorted Array.
     */
    private Pair<Integer>[] triangularOrigin(Pair<Integer>[] porigin) {
        Pair<Integer>[] originT = new Pair[porigin.length];
        int i;
        for(i = 0; i < porigin.length; i++) {
            originT[(porigin.length / 2) + (((i / 2) + (i % 2)) * powOne(i))] = porigin[i];
        }
        return originT;
    }
    
    /**
     * Returns -1 to the power of x.
     * @param x int: exponent
     * @return int
     */
    private int powOne(int x) {
        if((x % 2) == 0) return 1;
        else return -1;
    }
    
    /**
     * Applies force to each node, to push each other away and remove overlaps.
     * @param origin Pair<Integer>[]: List of origin nodes.
     */
    private void forcePush(Pair<Integer>[] porigin) {
        LinkedList<Integer> fifo = new LinkedList<>();
        int i;
        for(i = 0; i < porigin.length; i++) {
            fifo.add(porigin[i].getFirst());
        }
        
        while(fifo.size() > 0) {
            i = fifo.removeFirst();
            int j;
            Collection<VNode> succ = this.jgraph.getSuccessors(this.nodes[i]);
            Object[] successors = succ.toArray();
            for(j = 0; j < successors.length; j++) {
                fifo.add(getNodeID((VNode) successors[j]));
            }

            double x1 = this.nodes[i].getX() + (this.nodes[i].getWidth() / 2);
            double y1 = this.nodes[i].getY() + (this.nodes[i].getHeight() / 2);
            for(j = 0; j < this.nodecount; j++) {
                if(j == i) continue;
                double x2 = this.nodes[j].getX() + (this.nodes[j].getWidth() / 2);
                double y2 = this.nodes[j].getY() + (this.nodes[j].getHeight() / 2);
                double vx = x2 - x1;
                double vy = y2 - y1;
                double len = Math.sqrt(Math.pow(vy, 2) + Math.pow(vx, 2));
                double f1;
                double f2;
                if(this.nodes[i].getWidth() > this.nodes[i].getHeight()) f1 = this.nodes[i].getWidth() / 2;
                else f1 = this.nodes[i].getHeight() / 2;
                if(this.nodes[j].getWidth() > this.nodes[j].getHeight()) f2 = this.nodes[j].getWidth() / 2;
                else f2 = this.nodes[j].getHeight() / 2;
                double dst = 1.2 * (f1 + f2);
                double xf;
                double yf;
                if((len < dst) && ((x1 != x2) || (y1 != y2))) {
                    if(vy >= 0) {
                        yf = y1 + ((dst * vy) / Math.sqrt(Math.pow(vx, 2) + Math.pow(vy, 2)));
                    }
                    else {
                        yf = y1 - ((dst * vy) / Math.sqrt(Math.pow(vx, 2) + Math.pow(vy, 2)));
                    }
                    xf = ((vx * (yf - y1)) / vy) + x1;
                    this.nodes[j].setX(xf - (this.nodes[j].getWidth() / 2));
                    this.nodes[j].setY(yf - (this.nodes[j].getHeight() / 2));
                    if(this.debug) System.out.println(this.nodes[i].getId() + " pushed " + this.nodes[j].getId() + " from (" + x2 + "|" + y2 + ") to (" + xf + "|" + yf + ")");
                }
            }
        }
    }
    
    /**
     * Graph visualization for debugging output.
     * @param layout Layout<VNode, Connection>: layout to visualize.
     */
    private void testvis(Layout<VNode, Connection> layout) {
        VisualizationViewer<VNode, Connection> vis = new VisualizationViewer<>(layout);
        vis.setPreferredSize(new Dimension(1280, 720));
        Transformer<VNode, Paint> vertexPaintT = new Transformer<VNode, Paint>() {
            @Override
            public Paint transform(VNode n) {
                return Color.GREEN;
            }
        };
        final Stroke edgeStroke = new BasicStroke();
        Transformer<Connection, Stroke> edgeStrokeT = new Transformer<Connection, Stroke>() {
            @Override
            public Stroke transform(Connection c) {
                return edgeStroke;
            }
        };
        vis.getRenderContext().setVertexFillPaintTransformer(vertexPaintT);
        vis.getRenderContext().setVertexLabelTransformer(new IDLabeller());
        vis.getRenderContext().setEdgeStrokeTransformer(edgeStrokeT);
        vis.getRenderContext().setEdgeLabelTransformer(new IDLabeller());
        vis.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
        DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
        gm.setMode(ModalGraphMouse.Mode.TRANSFORMING);
        vis.setGraphMouse(gm);
        JFrame frame = new JFrame("Jung Display");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.getContentPane().add(vis);
        frame.pack();
        frame.setVisible(true);
    }
    
    /**
     * Gets the model-ID for the given Node.
     * @param pnode VNode: the given Node.
     * @return Integer: ID of the given Node.
     */
    private Integer getNodeID(VNode pnode) {
        int i;
        for(i = 0; i < this.nodecount; i++) {
            if(this.nodes[i].equals(pnode))
                return i;
        }
        return -1;
    }
    
    /**
     * Labeller that labels VNodes and Connections by their ID.
     * @param <V> VNode or Connection to be transformed.
     */
    class IDLabeller<V extends Object> implements Transformer<V, String> {
        
        @Override
        public String transform(V v) {
            if(v instanceof VNode) {
                VNode node = (VNode) v;
                return node.getId();
            }
            else if(v instanceof Connection) {
                Connection conn = (Connection) v;
                return conn.getId();
            }
            else{
                return v.toString();
            }
        }
    }
    
}
